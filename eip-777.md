## Preamble

    EIP: 777
    Title: A New Advanced Token Standard
    Author: Jordi Baylina @jbaylina, Jacques Dafflon @jacquesd, Thomas Shababi @tshabs
    Type: Standard Track
    Category: ERC
    Status: Draft
    Created: 2017-11-19
    Requires: 672 (draft)

## Simple Summary

Creates a standard interface for a token contract.

## Abstract

This standard defines a new way to interact with a Token Contract. This standard takes advantage of [ERC-672](https://github.com/ethereum/EIPs/issues/672).

## Motivation

This standard tries to improve the widely used ERC20 token. The main advantages of this contract are:

1. Uses the same philosophy that Ether is used when tokens are sent with `send(dest, value, data)`.
2. A `tokenFallback` can be defined in any contract and in any regular address in a way that this code is triggered when tokens are received. This avoids the double call needed in the ERC20 standard.
3. Contracts and regular addresses can control which contracts are authorized to be received.
4. The token holder can "authorize" and "deauthorize" operators that can manage their tokens. This operators generally are going to be verified contracts like an exchange, a check processor or an automatic charging system.
5. Besides the `bytes data` field, a `bytes32 ref` field is also added in each payment that can be freely used by the operators and the users.
6. It can be used in a backwards compatible way with wallets that do not contain the `tokenFallback` function

## Specification

### IToken (Token Contract)

``` ts
interface IToken {
    function name() public constant returns (string);
    function symbol() public constant returns (bytes32);
    function totalSupply() public constant returns (uint256);
    function decimals() public constant returns (uint8);
    function balanceOf(address owner) public constant returns (uint256);

    function send(address to, uint256 value) public;
    function send(address to, uint256 value, bytes userData) public;
    function send(address to, uint256 value, bytes userData, bytes32 ref) public;

    function authorizeOperator(address operator, bool authorized) public;
    function isOperatorAuthorizedFor(address operator, address tokenHoler) public constant returns (bool);
    function operatorSend(address from, address to, uint256 value) public;
    function operatorSend(address from, address to, uint256 value, bytes userData) public;
    function operatorSend(address from, address to, uint256 value, bytes userData, bytes32 ref) public;

    event Send(address indexed from, address indexed to, uint256 value, bytes data, bytes32 indexed ref, address operator);
    event Mint(address indexed to, uint256 value);
    event Burn(address indexed from, uint256 value);
    event AuthorizeOperator(address indexed operator, address indexed tokenHolder, bool authorize);
}
```

The token must use EIP-672 to implement IERC777.

#### Methods
##### name

``` ts
 function name() public constant returns (string)
```

Returns the name of the token - e.g. `"MyToken"`.

*Note*: This method SHOULD NOT be implemented explicitly. Instead declare a
public state variable (`string public name`) and let the solidity compiler create the getter.

> **returns:** Name of the token

<br/>

##### symbol

``` ts
function symbol() public constant returns (bytes32)
```
Returns the symbol of the token. E.g.  `"MYT"`.

*Note*: This method SHOULD NOT be implemented explicitly. Instead declare a
public state variable (`string public symbol`) and let the solidity compiler
create the getter.

> **returns:** Symbol of the token

<br/>

##### totalSupply

``` ts
function totalSupply() public constant returns (uint256)
```
Get the total supply of minted tokens.

> **returns:** Total supply of tokens currently in circulation.

<br/>

##### decimals

``` ts
function decimals() public constant returns (uint8)
```
Returns the number of decimals the token uses - e.g. `8`, means to divide the token amount by `100000000` to get its user representation.

*Note*: This method SHOULD NOT be implemented explicitly. Instead declare a
public state variable (`string public decimals`) and let the solidity compiler
create the getter.

> **returns:** Number of decimals used by the token.

<br/>

##### balanceOf

``` ts
function balanceOf(address owner) public constant returns (uint256)
```
Get the account balance of the account with address `owner`.
> **parameters**
> - `owner`: Owner of the account for which the balance is returned
>
> **returns:** Amount of token held by `owner` in the token-contract.

<br/>

##### send

``` ts
function send(address to, uint256 value) public
function send(address to, uint256 value, bytes userData) public
function send(address to, uint256 value, bytes userData, bytes32 ref) public
```

Send `value` amount of tokens to address `to`.

This call MUST fire the `Send` event. This call MUST call the `tokenFallback` method on the contract implementing `ITokenFallback` as returned by a ERC-672 reverse lookup on the `to` address.

This call MUST NOT call `tokenFallback` if a ERC-672 reverse lookup does not return an address implementing `ITokenFallback`.

The function MUST `throw` if:
 - `msg.sender` account balance does not have enough tokens to spend
 - `to` is a contract which does not implement the `ITokenFallback` interface.

*NOTE*: Sending a value of `0` is valid and MUST be treated as a regular send.

> **parameters**
> - `to`: tokens recipient
> - `value`: amount of tokens transferred
> - `userData`: information attached to the transaction
> - `ref`: reference associated with the transaction

<br/>

##### authorizeOperator
``` ts
function authorizeOperator(address operator, bool authorize) public
```
Authorize/Deautorize a third party `operator` to manage (send) `msg.sender`'s tokens.

*NOTE*: By default the token holder (`msg.sender`) MUST be the only one allowed manage its tokens. This method is intended to allow verified contracts like an exchange, a check processor or an automatic charging system to manage tokens on
someone's behalf.

*NOTE*: A token holder CAN authorize multiple operators at the same time.

> **parameters**
> - `operator`: Address which will be granted/denied rights to manage the tokens.
> - `authorize`: `true` to allow `operator` to manage tokens, `false` to deny or revoke the right to manage tokens.

<br/>

##### isOperatorAuthorizedFor

``` ts
function isOperatorAuthorizedFor(address operator, address tokenHolder) public constant returns (bool)
```

Check whether an address (`operator`) is allowed to manage the tokens held by another address (`tokenHolder`).

> **parameters**
> - `operator`: address which will be granted/denied rights to manage the tokens.
> - `tokenHolder`: address which holds the tokens to be managed.

<br/>

##### operatorSend

``` ts
function operatorSend(address from, address to, uint256 value) public
function operatorSend(address from, address to, uint256 value, bytes userData) public
function operatorSend(address from, address to, uint256 value, bytes userData, bytes32 ref) public
```

Send `value` amount of tokens from the address `from` to the address `to`.
`msg.sender` MUST be an authorized operator for the `from` address.

This call MUST fire the `Send` event. This call MUST call the `tokenFallback` method on the contract implementing `ITokenFallback` as returned by a ERC-672 reverse lookup on the `to` address.

This call MUST NOT call `tokenFallback` if a ERC-672 reverse lookup does not return an address implementing `ITokenFallback`.

The method MUST throw if:
 - `from` account balance does not have enough tokens to spend.
 - `to` is a contract which does not implement the `ITokenFallback` interface.
 - `msg.sender` is not an authorized operator for `from`.

*NOTE*: The `from` address MUST first call `authorizeOperator` on an address to allow this address to call `operatorSend` on behalf of the `from` address.

> **parameters**
> - `from`: token holder (payer)
> - `to`: tokens recipient
> - `value`: amount of tokens transferred
> - `data`: information attached to the transaction
> - `ref`: reference associated with the transaction

<br/>

#### Events

##### Send

``` ts
event Send(address indexed from, address indexed to, uint256 value, bytes data, bytes32 indexed ref, address operator)
```

Indicate a transaction of `value` tokens from the `from` address to the `to` address.

This event MUST be fired on a successful call to `send` and `operatorSend`.

> **parameters**
> - `from`: token holder (payer)
> - `to`: tokens recipient
> - `value`: amount of tokens transferred
> - `data`: information attached to the transaction
> - `ref`: reference associated with the transaction

<br/>

##### Mint

``` ts
event Mint(address indexed to, uint256 value)
```

Indicate the minting of `value` tokens to the `to` address.

This standard does not enforce a specific way to mint tokens as this can be done in various ways depending on the use case of the tokens.

However, this event MUST be fired every time tokens are minted and credited to a `to` recipient address. A `Send` event with the `0x0` `from` address MUST NOT be fired.

This call MUST call the `tokenFallback` method on the contract implementing `ITokenFallback` as returned by a ERC-672 reverse lookup on the `to` address.

This call MUST NOT call `tokenFallback` if a ERC-672 reverse lookup does not return an address implementing `ITokenFallback`.

> **parameters**
> - `to`: tokens recipient
> - `value`: amount of tokens minted

<br/>

##### Burn

``` ts
event Burn(address indexed from, uint256 value)
```

Indicate the burning of `value` tokens from the `from` address.

This standard does not enforce a specific way to burn tokens as this can be done in various ways depending on the use case of the tokens.

However, this event MUST be fired every time tokens are burnt and taken from a `from` recipient address. A `Send` event with the `0x0` `to` address MUST NOT be fired.

> **parameters**
> - `from`: tokens holder
> - `value`: amount of tokens burnt

<br/>

##### AuthorizeOperator

``` ts
event AuthorizeOperator(address indexed operator, address indexed tokenHolder, bool authorized)
```

Indicate that the `operator` address is allowed/denied the right to manage the token of (i.e. is/isn't an operator for) the address `tokenHolder`.

This event MUST be fired on a successful call to `authorizeOperator`. The `authorize` boolean value of the call MUST be passed as the `authorized` boolean value of the event to communicate the current state.

> **parameters**
> - `operator`: Address which is granted/denied rights to manage the tokens.
> - `tokenHolder`: address which holds the tokens to be managed.
> - `authorized`: `true` to allow `operator` to manage tokens, `false` to deny or revoke the right to manage tokens.

<br/>

### ITokenFallback (Token Recipient)

Any recipient can define the `ITokenFallback` interface via EIP-672.

``` ts
interface ITokenFallback {
    function tokenFallback(address from, uint value, bytes data) public;
}
```
#### Methods

##### tokenFallback

``` ts
function tokenFallback(address from, uint value, bytes data) public
```

Notify the transmission of `value` tokens from the `from` address to the `to` address.

> **parameters**
> - `from`: token holder (payer)
> - `to`: tokens recipient
> - `value`: amount of tokens transferred
> - `data`: information attached to the transaction

The data must follow the next format:

0-31 bytes: `to` -> Address of the recipient of the token. This will generally be the address
of the contract implementinf this interface (`address(this)`)  but can also be a diferent
address if ITokenFallback is implemented via a "Proxy"
32-63 bytes: `operator` -> Address of the operator that trigered the 'send'. This is going to be
the address of the token contract for a normal `send` and the address of the operator for a
`operatorSend`
64-95 bytes: `ref` -> Reference of the payment set by the operator generaly.
96-127 bytes: `reserved` -> Reserved for future versions. MUST be set to 0
128- bytes: `userData` -> Variable length of user defined data


## Rationale

This standard solves some of the problems of the ERC223 and goes an step further by allowing operators (generally contracts) that can manage the tokens in the same way that the ERC20 with infinite `approve` was allowed.

Also the usage of EIP-672 allows backwards compatibility with wallets and proxy contracts without having to be redeployed.

## Backwards Compatibility

This EIP does not uses `transfer` and `transferFrom` and uses `send` and `operatorSendto` avoid mistakes in knowing which interface you are using. The main problem is that if you use a `transfer` in a token that the user think itâ€™s a ERC777 token but it is an ERC20 token, the tokens could be locked in a contract.

This standard permits the implementation of ERC20 methods `transfer`, `transferFrom` and approve but they should be limited to only being called from old contracts.

This functions will call the `tokenFallback` function. And will return true or throw. They will never return false.

When the destination address does not implement `ITokenFallback`, the recommended action to do is:
1. If the destination is a regular address then accept the Send.
2. If the destination is a contract and the call is made from a `send` or a `operatorSend` then throw.
3. If the call is made from the ERC20 `transfer` throw.
4. If the call is made from the ERC20 `transferFrom` accept it.

## Test Cases

The implementation repos includes all the tests.

## Implementation

A simple implementation will be posted in brief
https://github.com/Giveth/yogatoken already implements this standard

## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
